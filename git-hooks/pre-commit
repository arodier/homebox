#!/bin/sh -e
#
## Pre-commit git-hook to be installed using the command:
## ln -s git-hooks/pre-commit .git/hooks/pre-commit
#

# Status codes
SUCCESS=0
SYSTEM_ERROR=10
ANSIBLE_LINT_ERROR=20
MARKDOWN_LINT_ERROR=30

# Default status
lint_result=$SUCCESS

# Convenience functions
if ! tput -V >/dev/null 2>&1; then
    tput() {
        :
    }
fi

# Run from the parent directory
script_file=$(readlink -f "$0")
script_dir=$(dirname "$script_file")
root_dir="$script_dir/.."

if ! ansible-lint --version >/dev/null 2>&1; then
    echo "Please install ansible-lint"
    exit $SYSTEM_ERROR
fi

# From .git/hooks/pre-commit.sample
if git rev-parse --verify HEAD >/dev/null 2>&1;then
    against=HEAD
else
    # Initial commit: diff against an empty tree object
    against=$(git hash-object -t tree /dev/null)
fi

# If there are whitespace errors or leftover merge conflicts markers,
# print the offending file names and fail.
git diff-index --check --cached "$against" --

# Create a temporary file to list ansible files to check
yaml_files=$(mktemp)
markdown_files=$(mktemp)

# Write the list of modified ansible YAML files to be committed
git diff-index --cached --name-only --diff-filter=ACMR -z "$against" -- \
    "$root_dir/playbooks/*.yml" \
    "$root_dir/roles/**/*.yml" \
    ":(exclude)*/files/*.yml" \
    ":(exclude)*/templates/*.yml" \
    | tr '\0' '\n' >"$yaml_files"

# Write the list of modified ansible YAML files to be committed
git diff-index --cached --name-only --diff-filter=ACMR -z "$against" -- \
    "$root_dir/docs/**/*.md" \
    | tr '\0' '\n' >"$markdown_files"

# Exit if no files are staged
if [ ! -s "$yaml_files" ] && [ ! -s "$markdown_files" ]; then
   echo "No files to check"
   exit
fi

# Display the number of files to check
nb_files=$(wc -w "$yaml_files" | cut -f 1 -d ' ')
printf "Diff against revision '%s', %d YAML files to check:\n" "$against" "$nb_files"

# Restart from an empty file
log_file="$root_dir/logs/ansible-lint.log"
truncate --size 0 "$log_file"

file_checked=0

# I am aware that some staged files may not be staged to the last version,
# but that the script will check the version on disk, i.e. the last one.
# This is a I accept, for 1) the sake of simplicity of the script,
# 2) because you are likely to commit the last version,
# and 3) ansible-lint may need to recurse into the original hierarchy,
# especially when using include_role

while read -r file; do

    file_checked=$((file_checked + 1))

    printf "[%02d/%02d] Checking file '%s': " "$file_checked" "$nb_files" "$file"

    status=$(ansible-lint --force-color "$file" 2>&1 | tee -a "$log_file")

    if expr "$status" : ".*ANSIBLE_LINT_ERROR.*" >/dev/null; then

        lint_result=$ANSIBLE_LINT_ERROR
        echo "Error(s)"

    elif expr "$status" : ".*WARNING.*" >/dev/null; then

        lint_result=$ANSIBLE_LINT_ERROR
        echo "Warning(s)"

    else
        echo "OK"
    fi

done < "$yaml_files"

if [ "$lint_result" != "$SUCCESS" ]; then

    echo "Errors found:"
    cat "$log_file"

    exit "$ANSIBLE_LINT_ERROR"
fi

# Display the number of files to check
nb_files=$(wc -w "$markdown_files" | cut -f 1 -d ' ')
printf "Diff against revision '%s', %d Markdown files to check:\n" "$against" "$nb_files"

# Restart from an empty file
log_file="$root_dir/logs/markdown-lint.log"
truncate --size 0 "$log_file"

file_checked=0


while read -r path; do

    file_checked=$((file_checked + 1))

    tput bold
    printf "[%02d/%02d] Checking file '%s': " "$file_checked" "$nb_files" "$path"
    filename=$(basename "$path")

    status=$(mdl "$path" 2>&1 | tee -a "$log_file")

    if [ "$status" != "" ]; then
        lint_result=$MARKDOWN_LINT_ERROR
        echo "Fails"
        tput sgr0
        echo "$status" | sed -En "s/.*$filename:(.*)/  line \\1/p"
        echo ""
    else
        echo "OK"
    fi

done < "$markdown_files"

exit $lint_result
